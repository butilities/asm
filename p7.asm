; Alexander Turenko. 3.5.3.
INCLUDE IO\io.asm

DEBUG EQU 0
N EQU 20
WS EQU 8

NODE STRUC
	ELEM DB WS DUP (?)
	COUNT DB 0
	LEFT DW 0
	RIGHT DW 0
NODE ENDS

HEAP SEGMENT
	HEAP_PTR DW ?
	DB (N*(TYPE NODE)) DUP(?)
HEAP ENDS

STACK SEGMENT STACK
	DB 256 DUP (?)
STACK ENDS

DATA SEGMENT
	CUR DB WS DUP (?)
	ERR_MESS DB '*ERROR*$'
DATA ENDS

CODE SEGMENT
	ASSUME SS:STACK, DS:DATA, CS:CODE

INIT_HEAP PROC
	PUSH BX
	PUSH CX

	MOV CX, HEAP
	MOV ES, CX

	MOV ES:HEAP_PTR, 2

	MOV CX, N-1
	MOV BX, 2
KO:	MOV ES:[BX].RIGHT, BX
	ADD ES:[BX].RIGHT, TYPE NODE
	ADD BX, TYPE NODE
	LOOP KO

	MOV ES:[BX].RIGHT, 0

	POP CX
	POP BX
	RET
INIT_HEAP ENDP

; DX - address of data
; ----- OUTPUT -----
; AX - address new item
NEW PROC
	PUSH BX
	PUSH SI

	MOV BX, ES:HEAP_PTR
	CMP BX, 0
	JE EPT; empty heap

	MOV SI, DX
	MOV AX, BX

	PUSH ES:[BX].RIGHT
	POP ES:HEAP_PTR

	IRPC SM, 0246
		PUSH WORD PTR [SI+SM]
		POP WORD PTR ES:[BX+SM].ELEM
	ENDM

	MOV ES:[BX].LEFT, 0
	MOV ES:[BX].RIGHT, 0
	MOV ES:[BX].COUNT, 1

	POP SI
	POP BX
	RET

EPT:	LEA DX, ERR_MESS
	OUTSTR
	FINISH
NEW ENDP

; SI - address of node
; DX - address of begin word
; ----- OUTPUT -----
; AL:	-1 - to left
;	 0 - equals
;	 1 - to right
CMPWORDD PROC
	PUSH SI
	PUSH BX
	PUSH CX
	PUSH AX

	MOV BX, DX
	MOV CX, 8
CWL:	MOV AL, BYTE PTR [BX]
	CMP AL, BYTE PTR ES:[SI].ELEM
	JB TOLEFT
	JA TORGHT
	INC SI
	INC BX
	LOOP CWL

	MOV AL, 0
	JMP CWQ

TOLEFT:	MOV AL, -1
	JMP CWQ
TORGHT: MOV AL, 1
	JMP CWQ


CWQ:	POP BX
	MOV AH, BH
	POP CX
	POP BX
	POP SI
	RET
CMPWORDD ENDP

; BX - address of root tree
; DX - address of begin word
; ----- OUTPUT -----
; SI - address of need node
; AL:	-1 - to left
;	 0 - equals
;	 1 - to right
SEARCH_NODE PROC
	MOV SI, BX
	CMP SI, 0
	JNE SNL

	PUSH AX
	CALL NEW
	MOV BX, AX
	MOV SI, AX
	POP AX
	MOV ES:[SI].COUNT, 0
	MOV AL, 0
	RET

; ----- begin of cycle -----
SNL:	CALL CMPWORDD; change AL
	CMP AL, 0
	JL SNTO_L
	JG SNTO_R
	JMP SNEX

SNTO_L:	CMP ES:[SI].LEFT, 0
	JE SNEX
	MOV SI, ES:[SI].LEFT
	JMP SNL
SNTO_R:	CMP ES:[SI].RIGHT, 0
	JE SNEX
	MOV SI, ES:[SI].RIGHT
	JMP SNL
; ----- end of cycle -----
SNEX:	RET
SEARCH_NODE ENDP

; BX - address of root tree
; DX - address of begin word
INS2TREE PROC
	PUSH AX
	PUSH SI

	CALL SEARCH_NODE
	CMP AL, 0
	JL INS_L
	JG INS_R
	INC ES:[SI].COUNT
	JMP INS_Q

INS_L:	CALL NEW
	MOV ES:[SI].LEFT, AX
	JMP INS_Q

INS_R:	CALL NEW
	MOV ES:[SI].RIGHT, AX
	JMP INS_Q

INS_Q:	POP SI
	POP AX
	RET
INS2TREE ENDP

; DX - address of begin word
; AL - last symbol
READWORDD PROC
	PUSH BX
	PUSH CX

	MOV BX, DX
	MOV CX, WS+1

RWL:	INCH AL
	CMP AL, ','
	JE ADD_SPACE
	CMP AL, '.'
	JE ADD_SPACE
	MOV [BX], AL
	INC BX
	LOOP RWL
	JMP RWE

ADD_SPACE:	MOV BYTE PTR [BX], ' '
		INC BX
	LOOP ADD_SPACE

RWE:	POP CX
	POP BX
	RET
READWORDD ENDP

; BX - address of begin word
OUTWORDD PROC
	PUSH BX
	PUSH CX
	MOV CX, WS
OWL:	OUTCH ES:[BX]
	INC BX
	LOOP OWL
	POP CX
	POP BX
	RET
OUTWORDD ENDP

; BX - address of begin node
OUTNODE PROC
	CALL OUTWORDD
	OUTCH ':'
	OUTCH ' '
	PUSH AX
	MOV AH, 0
	MOV AL, ES:[BX].COUNT
	OUTWORD AX
	POP AX
; ----- debug -----
	IF DEBUG
	OUTCH ' '
	OUTCH '#'
	OUTWORD BX
	OUTCH ' '
	OUTCH 'L'
	OUTCH ':'
	OUTWORD ES:[BX].LEFT
	OUTCH ' '
	OUTCH 'R'
	OUTCH ':'
	OUTWORD ES:[BX].RIGHT
	ENDIF
; ----- end of debug -----
	NEWLINE
	RET
OUTNODE ENDP

; BX - root of tree
PRINT_TREE PROC
	CMP BX, 0
	JE PTQ
	PUSH BX
	MOV BX, ES:[BX].LEFT
	CALL PRINT_TREE
	POP BX
	CALL OUTNODE
	PUSH BX
	MOV BX, ES:[BX].RIGHT
	CALL PRINT_TREE
	POP BX
PTQ:	RET
PRINT_TREE ENDP

START:	MOV AX, DATA
	MOV DS, AX

	CALL INIT_HEAP
	LEA DX, CUR
	MOV BX, 0; tree root

	OUTCH '>'
	OUTCH ' '

	MOV CX, N
ML:	CALL READWORDD
	CALL INS2TREE
	CMP AL, '.'
	JE MN
	LOOP ML
MN:	CALL PRINT_TREE

	FINISH
CODE ENDS
END START
